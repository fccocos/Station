## 应用层网络服务程序

### HTTP协议

HTTP协议是Web的核心。

HTTP协议实现了不同客户端和服务器之间的信息通信

只需要按照HHTP协议规定的格式来定义要进行接收和发送的信息，就可以使得服务器和客户端之间进行数据通信.

Web：它是客户端和服务器之间进行交流的基本内容，它由多个对象构成。这些对象是可以由URL进行寻址的**文件**，如HTML、JPG、CSS、MP3、MP4等

Web一般由一个或多个HTML以及渲染它的CSS文件和其他的资源文件构成

URL: 由服务器主机名和该对象的路径名构成

服务器主机名可以是主机的IP地址也可以是主机的域名

主机域名：它有由多个域名构成。如www.baidu.com. 首先先到www域名服务器中查找对应的下一级域名系统com然后再在com域名服务器中查到查找它的下一级域名baidu,然后通过baidu的域名服务找到对应的IP地址，然后将数据通过这个IP地址来发送到服务器端。

对象路径名：是指你所需要的文件在服务的什么位置。

### HTTP的交互过程

1. 客户端发送一个请求
2. 服务器在接收到客户端的请求后发送一个响应给客户端。

### HTTP协议的内部过程

1. 建立连接。 通过申请一个socket来实现连接的建立。客户端打开一个套接字并把它绑定在一个端口上。
2. 发送请求。建立好一个连接后，客户端把请求消息送到服务器的监听端口上，完成提出请求动作。
3. 响应请求。服务器在处理完毕客户端请求后，要向客户端发送响应消息。
4. 关闭连接。客户端和服务器都可以通过关闭套接字来结束TCP/IP对话

### HTTP协议的请求头部格式

```
方法 URI 协议版本
请求首部字段

内容实体
```

例如
```sh
GET /form/entry HTTP/1.1 # 请求行
Host: hackr.jp
Connection: keep-alive
Comtent-Type: application/x-www-form-urlencoded
Content-Length: 16

name=ueno&age=37&usrid=xxx
```

### HTTP协议的响应头部

```sh
协议版本 状态码 状态信息
响应首部字段

响应实体内容
```

例如

```sh
HTTP/1.1 200 OK
Data: Tue, 10 Jul 2012 06:50:15 GMT
Content-Length: 362
Content-Type: text/html

.....

```

## FTP协议和服务

### FTP协议的步骤

1. 通过FTP接入命令，让FTP客户端接口连接远端的FTP服务器主机。
2. 连接成功后，远程的FTP服务器主机要求输入合适的用户名和密码，在用户名和密码得到正确的验证后，进入到正常的FTP下载过程。
3. 与本地的文件系统相似，可以在远程的FTP服务器上进行文件目录的转换，进入到合适的目录，进行相关的操作。
4. 对目标文件的下载，需要使用FTP协议特定的命令行格式，FTP服务器进行解析后，与客户端之间进行文件传输
5. 文件传输成功后，客户端关闭与服务器之间的FTP连接

### FTP是双端口服务器

两个端口：21传输控制信息 20传输数据，数据传输是非持久化，服务器需要维护与客户端之间的控制信息连接。


### FTP协议的工作模式

- 主动模式：客户端主动告诉服务器数据连接的端口
- 被动模式：由服务器随机选取一个高位端口

## TCP网络编程基础

通用套接字数据结构

```c
struct sockaddr{
    sa_family_t sa_family;
    char sa_data[14];
}
```

`typedef unsigned short sa_family_t`

以太网套接字数据结构

```c
struct sockaddr_in{
    u8 sin_len;
    u8 sin_family;
    u16 sin_port;
    struct in_addr sin_addr; // 32位IP地址
    char sin_zero[8]; // 8位保留位
};
```

```c
struct in_addr{
    u32 s_addr; // 网络字节序，32位的ip地址
}
```

### TCP的服务器和客户端程序设计模型

服务器端

0. 初始化服务器自身的套接字 `socket()`
1. 绑定套接字 `bind()`
2. 监听套接字 `listen()`
3. 接收套接字 `accept()`
4. 接收数据 `recive()`
5. 发送数据 `send()`
6. 关闭连接 `close()`

客户端

0. 初始化套接字 `bind()`
1. 连接套接字 `connect()`
2. 发送数据 `send()`
3. 接收数据 `recive()`
4. 关闭连接 `close()`

### 创建TCP连接所有函数详解

1. `int socket(int domain, int type, int protocol)` 初始化套接字
    - `domain`用于设置网络通信的域，socket函数通过这个参数来选择合适的通信协议族。常用的协议族有`PF_UNIX`本地通信 `AP_INET` IPv4协议 `AP_INET6` IPv6协议
    - `type` socket通信的类型
      - `SOCK_STREAM` 字节流,TCP
      - `SOCK_DGRAM` 包，UDP
      - `SOCK_SEQPACKET` 序列化包，提供一个序列化的、可靠的、双向的基于连接的数据传输通道，数据长度定长。每次调用读系统调用时需要将数据全部读出
      - `SOCK_RAW` RAW类型，提供原始网络协议访问
      - `SOCK_RDM` 提供可靠的数据报文，不过数据可能会有乱序
      - `SOCK_PACKET` 这是一个专用类型，不能在通用程序中使用
   - `protocol` 用于指定某个协议的特定类型，一般一个协议中只有一个特定类型，所以`protocol`只能设置为0.

2. `int bind(int sockfd, const struct sockaddr *my_addr, socklen_t addrlen);` 绑定套接字的地址和端口

```c
#include <sys/types.h>
#include <sys/socket.h>
/*初始化套接字*/
int sockfd = socket(AF_INET, SOCK_STREAM,0);

/*初始化socket地址*/
struct sockaddr_in sockaddr
sockaddr.sin_family = AF_INET
sockaddr.sin_prot = htons(8080)
sockaddr.sin_addr.s_addr = inet_addr("192.168.3,61");
bzero(&(sockaddr.sin_zero),0);
/*绑定套接字的IP地址和端口*/
int ret = bind(sockfd, (struct sockaddr*)&sockaddr, sizeof(struct sockaddr))
```

3. `int listen(int sockfd, int backlog)` 监听端口，是否有数据到来
   - `sockfd`socket文件描述符
   - `backlog` 在`accept`函数处理之前在等待队列中的客户端的数量，即等待队列的长度。大多数系统都设为20，也可以设置为5或10

4. `int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen)` 处理在监听等待队列中的客户端请求，并返回一个新的socket描述符表示客户端的连接。服务器端可以用这个新的文件描述符来与客户端进行通信。
   - `sockfd`
   - `addr` 用于存放客户端的套接字，它是一个指针，它将传递给TCP/IP协议栈
   - `addrlen` 套接字的长度

5. `int connect(int sockfd,struct sockaddr * serv_addr, int addrlen)` 客户端连接到服务器
   - `sockfd` 客户端的socket文件描述符
   - `serv_addr`  为一个`sockaddr`的指针，其中包含了客户端连接到服务器的IP地址和端口号
   - `addrlen` 为套接字的长度

6. 可以使用通用IO操纵来读写socket,如`read`、`write`、`pread`、`pwrite`、`readv`、`writev`、`preadv`、`pwritev`等

### 一个简单C/S模型

服务器

```c
#include <sys/types.h>
#include <sys/socket.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <errno.h>
#define LOCAL_PORT 8080
#define LOCAL_ADDR "localhost"

int main()
{
    int local_sockfd, client_sockfd;
    struct sockaddr_in local_addr,client_addr;
    int ret;

    char buffer[1024]{0};

    local_sockfd = socket(AF_INET, SOCK_STREAM, 0);
    if(local_sockfd == -1)
    {
        perror("socket");
        exit(EXIT_FAILURE);
    }

    //初始化sockaddr
    local_addr.sin_family = AF_INET;
    local_addr.sin_addr.un_addr = htonl(INADDR_ANY);//本地回环接口
    local_addr.sin_port = htons(LOCAL_PORT);

    // 绑定端口和ip地址
    ret = bind(local_sockfd, (struct sockaddr*)&local_addr, sizeof(struct sockaddr));
    if(ret == -1)
    {
        perror("bind");
        exit(EXIT_FAILURE);
    }

    // 监听套接字
    ret = listen(local_sockfd, LISTEN_QUE_LEN);
    if(ret == -1)
    {
        perror("listen");
        exit(EXIT_FAILURE);
    }

    /*事件处理循环*/
    while(1)
    {
        // 接收客户端的连接请求
        client_sockfd = accept(local_socket, (struct sockaddr*)&client_addr, sizeof(struct sockaddr));
        
        // fork一个子进程来处理与客户端的交互,父进程用于维护本地套接字
        pid_t p = fork();
        if(p > 0) // 父进程
        {
            //如果监听出现意外，则关闭本地监听
            if(client_sockfd==-1) 
            {
                perror("accept");
                close(local_sockfd);
                exit(EIXT_FAILURE);
            }
            
        }
        else if(p==0) // 子进程
        {
            // 处理来自客户端的求情
            // 读取客户端的请求
            ret = read(client_sockfd, buffer, sizeof(buffer));
            if(ret == -1) perror("read");
            printf("%s\n", buffer);
            
            // 给客户端发送响应
            size_t len = strlen(buffer);
            bzero(buffer,sizeof(buffer));
            sprintf(buffer, "%d bytes altogether\n", len);
            ret = write(client, buffer, strlen(buffer)+1);
            if(ret == -1) perror("write");

            // 关闭client
            close(client_sockfd);
            
        }
    }

    
}

```
客户端

```c
#include <sys/types.h>
#include <sys/socket.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <strings.h>
#include <errno.h>

#define SERV_PORT 8080

int main()
{
    int sockfd;
    struct sockaddr_in serv_addr;
    int ret;

    sockfd = socket(AF_INET, SOCK_TREAM, 0);
    if(sockfd == -1)
    {
        perror("scoket");
        exit(EXIT_FAILURE);
    }
    ret = connect(sockfd, (struct sockaddr*)&serv_addr, sizeof(struct socketaddr));
    if(ret == -1)
    {
        perror("connect");
        exit(EXIT_FAILURE);
    }

    //处理来自服务器的响应
    size_t size=0;
    char buffer[1024]{0};
    while(1)
    {
        fprintf(stdout, "client:");
        bzero(buffer,sizeof(buffer));
        fputs(buffer, stdin);
        write(sockfd, buffer, strlen(buffer)+1);

        fprintf(stdout, "\n================收到响应================\n");

        bzero(buffer, sizeof(buffer));
        read(sockfd,buffer,strlen(buffer));
        fgets(buffer, stdout);
    }
    

}


```

 ## 服务器和客户端信息获取

 ### 字节序的转换

 ```c
#include <arpa/inet.h>

uint32_t htonl(uint32_t hostlong);
uint16_t htons(uint16_t hostshort);
uint32_t ntohl(uint32_t netlong);
uint16_t ntohs(uint16_t netshort);
 ```  

 ### 字符串IP地址和二进制IP地址的转换

```c
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

int inet_aton(const char* cp, struct in_addr* inp);//将点分十进制转换为in_addr值
in_addr_t inet_addr(const char* cp);//将字符串转换为in_addr值
in_addr_t inet_network(const char* cp);//将字符串IP的网络部分转换为in_addr类型
char* inet_ntoa(struct in_addr in);// 将in_addr转换为字符串
struct in_addr inet_makeaddr(int net, int host); //将网络号和主机号合并成IP地址

in_addr_t inet_lnaof(struct in_addr in);//获取主机部分
in_addr_t inet_netof(struct in_addr in);//获取网络部分
```
以上函数是不可重入的

```c
#include <sys/types.h>
#include <sys/socket.h>
#include <arpa/inet.h>

int inet_pton(int af, const char* src, void *dst);

int inet_ntop(int af, const void *src, char *dst, socklen_t cnt);
```

### 判定套接字描述符

```c
struct stat st;
int ret = fstat(fd, &st);
if(ret == -1)
{
    perror("fstat");
    exit(EXIT_FAILURE);
}

if((st.st_mode&S_IFMT) == S_IFSOCK)
   return 1;
else
    return 0;

```

### 获取主机信息的函数

```c
#include <netdb.h>
extern int h_errno;
struct hostent *gethostbyname(const char* name); //通过域名获取主机名

/*需要注意的是：gethostbyname函数是一个不可重入函数*/

struct hostent{
    char *h_name;        // 主机名
    char **h_aliases;    // 主机别名列表
    int h_addrtype;      // 主机地址类型
    int h_length;        // 主机地址长度
    char **h_addr_list;  // 主机地址列表
};
```

```c
#include <sys/types.h>
#include <netdb.h>

struct hostent *gethostbyaddr(const void* addr, int len, int type); // 通过IP地址来获取主机名
/*gethostbyaddr是一个不可重入函数，因此在下一次赋值前需要先保存当前值*/

```
- 参数`addr`为一个空指针类型，在IPv4中指向一个`struct in_addr`结构体，因此要查询的IP地址要先存储到该结构体中再用`struct in_addr`结构体作为实参
- 参数`len`为第一个参数的大小
- 参数`type`为地址的类型，是AF_INET，还是AF_INET6，还是AF_UNIX

### 协议名称处理函数

```c
#include <netdb.h>

struct protoent *getprotoent(void); // 从协议文件中去读一行
struct protoent *getprotobyname(const char* name);// 冲协议文件中找到匹配项
struct protoent *getprotobynumber(int proto);//按照协议类型的值获取匹配项
void setprotoent(int stayopen);//设置协议打开状态
void endprotoent(void); // 关闭协议文件

/*上述所有函数都是对文件/etc/protocols中的记录做操作*/
/*文件中记录了协议的名称、值和别名等，与结构struct protoent的定义一致*/

struct protoent{
    char *p_name;
    char **p_aliases;
    int p_proto;
}

```
```c
#include <netdb.h>
#include <stdlib.h>
#include <stdio.h>

int main()
{
    //打开协议文件
    setprotoent(1);
    //读行
    struct protoent *cur = getprotoent();
    fprintf(stdout,
            "\n\tprotocol_name\tprotool_number\tprotocol_aliases\n");
    while (cur != NULL)
    {
        fprintf(stdout, "\t%8s\t%8d\t%8s\n",
                cur->p_name, cur->p_proto, *(cur->p_aliases));

        cur = getprotoent();
    }
    endprotoent();
}
```

| protocol_name |  protocol_number|  protocol_aliases|
|:-------------:|:--------------:|:-----------------:|
|       ip      |         0      |        IP|
|   hopopt      |         0      |    HOPOPT|
|     icmp      |         1      |      ICMP|
|     igmp      |         2      |      IGMP|
|      ggp      |         3      |       GGP|
|  ipencap      |         4      |  IP-ENCAP|
|       st      |         5      |        ST|
|      tcp      |         6      |       TCP|
|      egp      |         8      |       EGP|
|      igp      |         9      |       IGP|
|      pup      |        12      |       PUP|
|      udp      |        17      |       UDP|
|      hmp      |        20      |       HMP|
|  xns-idp      |        22      |   XNS-IDP|
|      rdp      |        27      |       RDP|
|  iso-tp4      |        29      |   ISO-TP4|
|     dccp      |        33      |      DCCP|
|      xtp      |        36      |       XTP|
|      ddp      |        37      |       DDP|
| idpr-cmtp     |        38      |  IDPR-CMTP|
|     ipv6      |        41      |      IPv6|
| ipv6-route    |        43      |  IPv6-Route|
| ipv6-frag     |        44      |  IPv6-Frag|
|     idrp      |        45      |      IDRP|
|     rsvp      |        46      |      RSVP|
|      gre      |        47      |       GRE|
|      esp      |        50      |  IPSEC-ESP|
|       ah      |        51      |  IPSEC-AH|
|     skip      |        57      |      SKIP|
| ipv6-icmp     |        58      |  IPv6-ICMP|
| ipv6-nonxt    |        59      |  IPv6-NoNxt|
| ipv6-opts     |        60      |  IPv6-Opts|
|     rspf      |        73      |      RSPF|
|     vmtp      |        81      |      VMTP|
|    eigrp      |        88      |     EIGRP|
|     ospf      |        89      |   OSPFIGP|
|    ax.25      |        93      |     AX.25|
|     ipip      |        94      |      IPIP|
|  etherip      |        97      |   ETHERIP|
|    encap      |        98      |     ENCAP|
|      pim      |       103      |       PIM|
|   ipcomp      |       108      |    IPCOMP|
|     vrrp      |       112      |      VRRP|
|     l2tp      |       115      |      L2TP|
|     isis      |       124      |      ISIS|
|     sctp      |       132      |      SCTP|
|       fc      |       133      |        FC|
| mobility-header|      135      |  Mobility-Header|
|  udplite      |       136      |   UDPLite|
| mpls-in-ip    |       137      |  MPLS-in-IP|
|    manet      |       138      |    (null)|
|      hip      |       139      |       HIP|
|    shim6      |       140      |     Shim6|
|     wesp      |       141      |      WESP|
|     rohc      |       142      |      ROHC|

## 数据的IO和复用

### IO函数

1. `ssize_t recv(int s, void* buf, size_t len, int flags);`
   - 功能：接收网络数据
   - 参数说明
     - `s`为套接字文件描述符
     - `buf` 用于缓存接收到的网络数据
     - `len` 缓冲区的大小
     - `flags` 用于设置接收数据的方式
       - `MSG_DONTWAIT` 非阻塞操作，立刻返回，不等待
       - `MSG_ERRQUEUE` 错误消息从套接字错误队列接收
       - `MSG_OOB` 接收外带数据
       - `MSG_PEEK` 用于查看可读的数据，在recv执行后，内核不会将这些数据丢弃
       - `MSG_TRUNC` 在接收到数据后，如果用户的缓冲区大小不足以完全复制缓冲区中的数据，则将数据截断，其他数据截短
       - `MSG_WAITALL` 告诉内核在没有读到数据之前不得返回。
    - 返回值
      - 成功返回0
      - 失败返回-1，并设置errno

2. `ssize_t recvform(int s, void* buf, size_t len, int flags);`
   - 与recv类似
   - 在默认情况下，内核将数据缓冲区中的内容全部复制到用户缓冲区中
     - 如果数据缓冲区的内容大于用户缓冲区，则内核会将与用户缓冲大小相同的内容复制到用户缓冲区，剩余的内容下次再传送。当把数据复制到用户缓冲区后，内核会将数据缓冲区中指定的内容销毁，并重新调整数据缓冲区
     - 如果使用了`MSG_WAITALL`，则内核会从数据缓冲区中复制与用户缓冲区大小相同的数据，如果数据缓冲区的数据大小小于用户缓冲区，则会一直等待直到足够大后，才会将数据复制到用户缓冲区
  
3. `ssize_t send(int s,void* buf, size_t len, int flags)`
    - 与`recv`类似
    - 如果函数的返回小于len，则说明缓冲区中仍有部分数据没有发送成功，这时需要重新发送数据。
    - 通常剩余数据发送方法是对原来的buf中的数据位置进行偏移，偏移的大小为已发送成功的字节数。

4. `ssize_t readv(int s, const struct iovec* vector,int count)`
5. `ssize_t writev(int s, const struct iovec* vector, int count)`

```c
struct iovec{
    void* iov_base;
    size_t iov_len;
};
```

6. `ssize_t recvmsg(int s, struct msghdr *msg, int flags)`
   - 将socket中接收到的数据放入到缓冲区msg中，操作方式由flags来指定
   - flags的标志与以上函数的标志一致

7. `ssize_t sendmsg(int s, struct msghdr* msg, int flags)`
   - 与recvmsg函数类似

`sendmsg`和`recvmsg`的主要区别在于sendmsg的操作方式由参数`flags`来决定，而recvmsg的操作方式由参数`msg`的成员变量`msg_flags`来决定。

```c
struct msghdir{
    void *msg_name; //一个指向struct sockadrr的指针，当socket还没有连接的时候有效
    socklen_t msg_namelen; //表示msgs_name的长度
    struct iovec *msg_iov; //
    size_t msg_iovlen;//
    void *msg_control;//指向缓冲区，根据msg_flags的值，会放入不同的值
    sockelen_t msg_controllen; // 为msg_control指向的缓冲区的大小
    int msg_flags;
}
```

4和5的头文件为`#include <sys/uio.h>`

1~3和6，7的头文件为`#include <sys/socket.h>` `#include<sys/types.h>`



### 使用IO函数的例子

#### 客户端处理框架

1. 对连接的输入参数进行判断，是否为要连接的服务器的地址。
2. 挂载SIGINT和SINGPIPE信号处理函数，用于处理子进程退出信号和套接字连接断开的情况
3. 建立一个流式套接字，结果放入到s中
4. 初始化socket地址
5. 连接服务器
6. 处理来自服务端的数据
7. 关闭socket

#### 服务器处理框架

与客户端处理框架类似。

将数据的处理单独分离开来，分别用三对IO函数进行数据的收发。

### IO 模型

#### 阻塞IO

在数据到来之前，程序会一直阻塞。对于绝大多数的IO函数而言，默认都是阻塞的。
`read/write` `pread/pwrite` `readv/writev` `send/recv` `sendto/recvfrom` `sendsmg/recvmsg` `preadv/pwritev`


#### 非阻塞IO

每次请求，内核都不会阻塞，会立即返回；当没有数据的时候，会返回一个错误

#### IO复用

IO复用模型，复用是指阻塞与非阻塞两中模式的混合使用。即在IO复用模型中可以加入超时等待时间，在超时等待时间内IO与阻塞情况一致， 然而如果超过超时时间没有数据到来，则系统立刻返回，不再等待。

#### 信号驱动IO

在进程开始的时候注册一个信号处理回调函数，进程继续执行，当信号发生时，即有了IO的时间，这里就有数据到来，利用注册的回调函数将到来的数据用`recvfrom`接收。

#### 异步IO

异步IO与前面的信号驱动IO相似，其区别在于信号驱动IO当数据到来的时候，使用信号通知注册的信号处理函数，而异步IO则在数据复制完成的时候才发送信号通知注册的信号处理函数


### select函数和pselect函数

#### select函数

```c
#include <sys/select.h>
#include <sys/time.h>
#include <sys/types.h>
#include <unistd.h>

int select(int nfds, fd_set* readfds, fd_set* writefds, fd_set* execeptfds, struct timeval* timeout);
```
- `nfds` 一个整形变量，比所有文件描述符集合中的文件描述符的最大值大1。使用select的时候必须计算最大值的文件描述符的值，将值通过nfds传入
- `readfds` 监视文件集中的任何文件是否有数据可以读，当select函数返回的时候，readfds将清除其中不可以读的文件描述符，只留下可读的文件描述符，即可以被recv、read等进行读数据操作的函数使用。
- `writefds` 监视文件集中的任何文件是否有数据可以写，当select函数返回的时候，writefds将清除其中不可以写的文件描述符，只留下可写的文件描述符，即可以被send、write等进行写数据操作的函数使用。
- `exceptfds` 监视文件集中的任何文件描述符是否发生异常, 其实它可以用于其他的用途。例如，监视外带数据OOB, 外带树使用MSG_OOB标志发送到套接字上，当select返回的时候，exceptfds将清除其中的其他文件描述符，只留下可读OOB数据。
- `timeout` 超时等待时间。当为NULL的时候将会时阻塞的。

- `sigmask` 信号掩码
- 读文件描述符中的文件可读、写文件描述符中的文件可写或者错误文件描述符中的文件发生错误的时候，返回大于0的值；超时返回0，出错返回-1并设置errno
- 操作文件描述符集合的四个宏函数
  - FD_ZERO() 请求文件描述符集合
  - FD_SET() 向某个文件描述符集合中添加文件描述符
  - FD_CLR() 从某个文件描述符集合中取出一个文件描述符
  - FD_ISSET() 判断一个文件描述符是否在一个文件描述符集合中

### pselect函数

```c
#include <sys/types.h>
#include <sys/times.h>
#include <unistd.h>
#include <sys/select.h>

int pselect(int nfds, fd_set * readfds, fd_set * writefds, fd_set * exceptfds, const struct timespec * timeout, const sigset_t * sigmask);

```

- pselect与select基本相同，只是多个一个参数，还有`timeout`的数据结构发生了改变

- 在实践中pselect函数用的很少。

`timval`定时器结构体

```c
struct timeval{ 
    time_t tv_sec; // 秒
    time_t tv_usec;//微妙
}

```
`timespec`定时器结构体

```c
struct timespec{
    long tv_sec; // 秒
    long tv_nsec; //纳秒
};
```

### poll函数和ppoll函数

```c

#include <poll.h>

int poll(struct pollfd* fd, nfds_t nfds, int timeout);
int ppoll(struct pollfd* fds, nfds_t nfds, const struct timespec *timeout, cosnt sigset_t *sigmask);

struct pollfd{
    int fd;
    short events;
    short revents;
}
```

## UDP编程

UDP编程基本与TCP编程类似，甚至比TCP编程更加的简单

### UDP编程框架

#### UDP服务器端

1. socket
2. bind
3. recvfrom
4. sendto
5. close

#### UDP客户端编程
1. socket
2. sendto
3. recvfrom
4. close

### UDP程序设计中的几个问题

#### UDP报文丢失(超时重传)

#### UDP报文乱序(发送端在数据段中加入数据包序列号)

#### UD缺乏流量控制（增大缓冲）

#### UDP协议的外出网络接口(用connect函数来绑定特定的网络接口（IP）和端口)

## 高级套接字  

UNIX域套接字 在`#include <sys/un.h>`中

```c
#define UNIX_PATH_MAX 108

struct sockaddr_un{
    sa_family_t sun_family;
    char sun_path[UNIX_PATH_MAX]; // 路径名，UNIX_PATH_MAX为路径字符的最大长度
}
使用`SUN_LEN(ptr)`宏函数来定义`struct scokaddr_un`的长度，默认大小为108
```
### 使用UNIX域套接字的限制和区别

1. 在使用bind函数进行套接字和地址的绑定的时候，地址结构中的路径名和路径名所所表示文件的默认权限为0777.
2. `struct sockaddr_in`中的成员`sun_path`必须时绝对路径，不能为相对路径
3. `connect`使用`UNIX`域套接字的时候，套接字的路径名必须是一个绑定在某个已经打开的UNIX域套接字上的路径名，而且套接字类型必须一致。如下会报错的情况。
   - 路径名存在，但是不是一个套接字
   - 路径名存在且是一个套接字，但是没有与该路径名相关联的打开的描述符
   - 路径名存在且是一个已经打开的套接字，但类型不符。

4. 提供一个没有记录边界的字节流接口
5. UNIX域套接字的`connect`函数发现监听套接字的队列满，会立刻返回一个`ECOMMEREFUSED`
6. 在未绑定的UNIX域套接字上发送数据报不会给它捆绑一个路径名。也就是说，发送方如果绑定一个路径名，则接受者无法发送应答数据报。给UNIX域套接字调用connect不会绑定一个路径名。

### 使用UNIX域套接字来实现进程间的描述符的传递

linux提供了一种方法，可以将一个进程中将一个已经打开的文件描述符传递给其他的任何进程。

1. 创建一个字节流或数据报的UNIX套接字
   - 如果两个进程之间有亲缘关系，例如，用fork复制出一个子进程，此时子进程和当前进程就有亲缘关系，则父子进程可以通过`socketpair()`创建的流式管道来，传递一个已经打开的文件描述符。
   - 如果进程之间没有亲缘关系，那么服务器必须要创建一个UNIX域字节流套接字，绑定一个路径名，让客户端连接到这个套接字，然后客户端可以向服务器发送一个请求以打开某个描述字，服务器将描述符通过UNIX套接字传回

2. 进程可以使用任何返回文件描述符的UNIX函数打开，例如`open`,`pipe`,`makefifo`,`socket`和`accept`等。可以在进程之间传递任何类型的文件描述符。
3. 发送进程创建一个msghdr结构，其中包含了要传递的描述符。发送进程调用sendmsg发送UNIX域socket。在sendmsg发送完后到recvmsg接收完之前传递的fd是关闭，但它仍会为接收进程保持打开状态，这就叫做fd的飞行状态。描述符的发送导致它的访问计数加1。
4. 接收进程调用recvmsg接收UNIX域套接字。通常接收进程收到的fd的编号与发送进程发送fd的编号是不同的。这是因为，传递fd不是传递fd的编号，而是通过创建一个新fd来指向发送进程的fd所指向的由内核维护的文件打开描述表中的文件打开描述信息。

### sockeppair()函数

```c
#include <sys/types.h>
#include <sys/socket.h>

int socketpair(int d, int type, int protocol, int sv[2]); // 创建一对匿名的已经连接的套接字。
```
- `d`表示协议族，一般为`AF_UNIX`或`AF_LOCAL`
- `type` 表示协议的类型，可以为`SOCK_STREAM`或`SOCK_DGRAM`, 一般情况下，建议使用`SOCK_STREAM`
- `protocol` 表示协议号，一般是0
- `sv`为一对sockfd, 用于创建传输fd的通道。
- Return 0 on success, Return -1 on error and set errno.

### 传递文件描述符的一个例子

## 广播

广播地址：主机号全为1的IP地址，如 `192.168.31.255 mask 255.255.255.0`
`255.255.255.255` 是一个特殊的广播地址，它向整个互联网进程广播，但是有更多的限制。一般情况下，路由器不会转发该地址。

地址为`255.255.255.255`的IP,在一些UNIX系统中被解释为再主机的所有网络接口上进行广播，而有的UNIX系统会选择主机的一个网络接口进行广播。

### 广播程序实现的步骤

1. 确定下一个或第一个接口的名字
2. 确定接口的广播地址
3. 使用广播地址进行广播

### 广播的实践

在局域网中发现服务器的地址，客户端使用广播地址来发送特定的数据来获取局域网中服务器的IP地址

## 多播

多播地址是确定的，D类地址都是多播地址，范围`224.0.0.0~239.255.255.255`

多播地址分为三类
  
  - 局部。`224.0.0.0~244.0.0.255`为路由协议和其他用途保留的地址，路由器并不转发数据此范围的IP包
  - 预留。`224.0.1.0~238.255.255.255`可用于全球范围或网络协议
  - 管理权限.`239.0.0.0~239.255.255.255` 共组织内部使用，类似于私有IP地址，不能用于Internet,可限制多播范围。

### 多播编程

使用setsockopt()和getsockopt()函数来实现，多播的选项是IP层的。

- IP_MULTICAST_TTL 设置多播的生存时间，在0~255之间
  
  ```c
  unsigned char ttl = 255;
  setsockopt(s, IPPROTO_IP, IP_MULTICAST_TTL, &ttl, sizeof(ttl));
  ```
- IP_ADD_MEMBERSHIP 将指定接口加入到多播组
- IP_DROP_MEMBERSHIP 将指定接口移除出多播组

```c
struct ip_mreq
{
    struct in_addr imn_multiaddr; // 多播组的地址
    struct in_addr imr_interface; // 网络接口的IP
}

struct ip_mreq mreq;
setsockopt(s,IPPROTO_IP, IP_ADD_MEMBERSHIP, &mreq, sizeof(mreq));
//可以使用IP_ADD_MEMBERSHIP将多个IP加入到一个多播组，也可以将一个IP加入到多个多播组。

setsockopt(s,IPPROTO_IP, IP_DROP_MEMBERSHIP,&mreq, sizeof(mreq));
// 将指定的IP从多播组中删除
```

- IP_MULTICAT_IF 获取组播的默认接口或设置组播的接口

```c
struct in_addr addr;
setsockopt(s,IPPROTO_IP, IP_MULTICAST_IF, &addr, sizeof(addr));
```

- IP_MULTICAST_LOOP 是否禁用组播数据回送

```c
unsigned char loop;//loop=0 表示允许回送，loop=1 表示禁止回送
setsockopt(s,IPPROTO_IP,IP_MULTICAST_LOOP,&loop, sizeof(loop));
```
### 多播程序设计框架

1. socket
2. 设置 IP_MULTICAST_TTL
3. 设置 IP_MULTICAST_LOOP
4. 加入多播组 IP_ADD_MEMBERSHIP
5. 发送数据 sendto
6. 接收数据 recvform
7. 从多播组中删除 IP_DROP_MEMBERSHIP

### 一个多播例子的服务器

多播服务器的程序设计，不需要服务器加入多播组，可以直接向某个多播组发送数据。

### 一个多播例子的客户端

  

