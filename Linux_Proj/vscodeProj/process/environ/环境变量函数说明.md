# 环境变量列表的两种获取方法

1. 使用全局变量environ

```c
#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <limit.h>

extern char** environ;

```

2. 使用main函数参数envp

```c
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char* argv[], char* envp[])
{
}
```

# 从程序中操作环境变量的函数

- getenv()

`getenv`函数通过环境变量名来获取环境变量的值

```c
#include <stdlib.h>

char* getenv(const char* name);//Return pointer to string, or NULL if no such variable

```

- putenv()

`putenv()`函数通过键值对形式的字符串来添加一个新的环境变量或修改一个已经存在的环境变量

```c
#include <stdlib.h>
int putenv(const char* string);//Return 0 on success, or nonzero on error
```

`tips`: 参数string不能为auto变量，否则程序每次调用putenv函数时都会重写string所指向的内存区域

- setenv()

`setenv`函数与`putenv`函数类似，但他是一个`glibc`库的一个非标准扩展系统调用

```c
#include <stdlib.h>
int setenv(const char* name, const char* value, int overwrite);//Return 0 on success, or -1 on error
```

`setenv`函数为环境变量分配一块缓冲区，并将`name`和`value`所指向的值复制到缓冲区中，以此创建一个新的环境变量。需要注意的是，`name`和`value`都不能有`=`字符出现，因为该函数会自动添加。

`name`参数：为环境变量的名字

`value`参数：为环境变量的值

`overwrite`参数：重写标志，如果为0，对于已经存在的环境变量不修改；如果为1，则用参数`value`设置的内容来覆盖已存在环境变量的值。

`setenv`函数，将环境变量复制到环境列表中。

- unsetenv()
`unsetenv()`函数：从环境变量中删除由`name`标识的环境变量

```c
#include <stdlib.h>
int unsetenv(const char* name);
```

`name`参数：指向需要删除环境变量名，其中不能包含`=`

- clearenv()

`clearenv()`函数用于清空环境列表`environ`变量

# 使用环境变量相关的函数来处理程序的环境变量

要求：

1. 清空环境 `clearenv()`
2. 向环境中逐一添加命令行参数所提供的环境变量定义
3. 如果环境中尚无名为GREET 的变量，就向环境中添加该变量
4. 从环境中移除名为BYE 的变量
5. 打印当前环境列表。
