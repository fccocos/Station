# 函数之间跳转

## 跳转函数的说明

```c
#include <setjump.h>
int setjmp(jmp_buf env);
void longjmp(jmp_buf env, int val);
```
`setjmp`和`longjmp`函数用来实现在函数间的跳转。

`setjmp`和`longjmp`函数之间的沟通，是通过参数`env`实现的，参数`env`中保存的当前进程环境的各种信息以及还保存了程序计数器和指针寄存器的副本。

`val`可以是任意的int类型值，用于区分出程序跳转至同一目标的不同起跳位置，即，调用`longjmp`的所在位置。

`setjmp`函数用于确定跳转目标，第一调用返回的值为0，第二次调用返回的是`longjmp`的`val`的值。

## 跳转函数的实现原理

1. 调用setjump函数时，env会保存当前进程换进的所有信息以及程序计数器和栈指针寄存器的副本。

2. 将发起longjmp的函数和之前调用setjmp的函数之间的函数栈帧从栈上剥离（此过程叫做解开栈），这一过程是通过调用setjump时保存了栈帧寄存器的副本来实现的，即通过env保存的之前栈指针的位置来覆盖当前栈指针的位置来实现的。

3. 重置程序程序计数器，用env保存的指令来覆盖当前运行指令，使得程序回到setjmp的位置。

## setjump函数的使用限制

1. 构成条件语句和迭代语句的整个表达式控制

2. 作为一元运算符`!`的操作对象

3. 可以作为比较操作的一部分

4. 作为独立的函数使用，没有嵌入到更到的表达式中。

5. 不可以赋值语句来保存其值

## 滥用longjump问题

调用setjump的函数返回后，再调用longjmp函数，将造成一个园中错误。因为longjmp不能跳转到一个已经返回的函数中。

## 编译优化问题

优化编译器会重组程序的指令执行顺序，并在CPU 寄存器中，而非RAM 中存储某些变量。这种优化一般依赖于反映了程序词法结构的运行时（run-time）控制流程。由于setjmp()和longjmp()的跳转操作需在运行时才能得以确立和执行，并未在程序的词法结构中有所反映，故而编译器在进行优化时也无法将其考虑在内。此外，某些应用程序二进制接口（ABI）实现的语义要求longjmp()函数恢复先前setjmp()调用所保存的CPU 寄存器副本。这意味着longjmp()操作会致使经过优化的变量被赋以错误值。

具备良好移植性的程序应在调用setjmp()的函数中，将指针变量和char、int、float、long 等任何简单类型的所有局部变量都声明为volatile。

将变量声明为volatile，是告诉优化器不要对其进行优化，从而避免了代码重组。
