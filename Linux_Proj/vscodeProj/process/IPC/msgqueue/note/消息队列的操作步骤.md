## 操作消息队列的函数

1. `key_t ftok(const char* name, char ch)` 将文件映射到systmev中，并返回key
2. `int msgget(int key, int msgflag)` 其中key为ftok函数的返回值，msgflag为打开消息队列方式的标志，`IPC_CREAT`和`IPC_EXCL`(它需要和`IPC_CREAT`一起使用，单独使用没有意义)
3. `int msgsnd(int msgid, const void* msgp, size_t msgsz, int msgflg)` `msgid`为消息队列的唯一标识，为msgget函数的返回值；`msgp`为指向消息缓存的指针；`msgsz`为消息缓冲区的大小；`msgflg`为发送消息到消息队列的方式的标识，`IPC_NOWAIT`（如果消息队列满了，函数李哥返回） 和`0`（如果队列满了，函数阻塞，直到有空闲的位置，才将消息发送到消息队列后再返回），还可以设置用户的读写权限。如`IPC_NOWAIT|0x0666`
4. `int msgrsv(int msgid, const void* msgp, size_t msgsz,long msgtyp, int msgflg)` 与`msgsnd`函数用法类似，只是多了一个`msgtyp`参数，该参数用于指定接收的消息类型，如果为0则返回消息队列中最旧的消息。
5. `int msgctl(int msgid, int cmd, struct msqid_ds *buf)` 用于控制消息队列的行为。`cmd`为怎样控制消息队列，`IPC_SET`(设置消息队列的属性和状态)和`IPC_STAT`（获取消息队列的属性和状态）；`struct msqid_ds`结构体是由内核创建和维护的，用于标识消息队列，在此结构体中存放了消息队列的相关信息。


## 消息队列使用流程

0. 构造一个消息缓冲结构体，结构体中的成员变量需要与`<linux/msg.h>`中的结构体类似，即必须有`int mtype` 和`char mtext[]`(mtext的大小可以自己定义，但是不得超过`<linx/msg.h>`中定义的mtext的最大值`MSGMAX`(8192))
1. 使用`ftok()`函数获取key
2. 用步骤1中获取的key,通过函数`msgget()`来打开或创建消息队列并返回一个消息队列的唯一标识msgid
3. 用步骤2中获取的msgid和对步骤0中声明的消息缓冲区进行初始化后，通过函数`msgsnd`来向消息队列发送消息。
4. 通过函数`msgrsv`来获取指定的消息
5. 通过函数`msgctl`来修改或获取消息队列的相关状态和属性
6. 通过函数`msgctl`和将`cmd`设置为`IPC_RMID`来删除消息队列



## 消息队列常用到的数据结构

消息缓存结构体

```c
struct smgbuf{
    int mtype;
    char mtext[];//mtext数组的大小根据需求而定，但不得超过MSGMAX(8912)
    int len;//此成员可选
}
```

消息队列id的数据结构

```c
struct smqid_ds{
    struct smg_perm; //消息的权限
    time_t smg_stime; //发送最后一个消息的时间
    time_t smg_rtime; //接收最后一个消息的时间
    time_t msg_ctime; //对消息队列最后一次修改的时间
    unsigned long _msg_cbytes; //在队列行所驻留的字节总数
    msgqnum_t msg_qnum; //当前消息队列中的消息数量
    msglen_t msg_qbytes //消息中能容纳的最大字节数
    pid_t msg_lspid; //发送最后一个消息的进程号
    pid_t msg_lrpid; //接收最后一个消息的进程号

};

```

消息权限数据结构

```c
struct smg_perm{
    key_t key; 
    uid_t uid;
    gid_t gid;
    uid_t cuid;
    gid_t guid;
    unsigned short mode;
    unsigned short seq;
}
```